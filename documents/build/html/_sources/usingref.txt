.. index:: 
	single: Using References; Introduction

================
Using References
================

In this chapter we will learn about using references.

This feature is added to the Ring language starting from Ring 1.18.

Contents:

* Introduction
* ref()/reference() function
* refcount() function
* The Tree Class
* Circular references
* Dependency Injection

.. index:: 
	pair: Using References; Introduction

Introduction
============

In Ring, Using the Assignment (=) operator copy variables by value.
Also, Adding a List/Object to another List create a new copy.
To change this behavior, We can use the Ref()/Reference() function.
This function doesn't create the reference directly. 
It's a flag setter, And Ring VM will decide when to create the reference. 

Once we have more than one reference, No need to use the Ref() again with the same list/object
Because Ring will use Copy by Reference with this list/object.
If the reference count drop to one again then Ring will change the behavior and
will use the default rule (copy lists/objects by value).

In general Ring as a language is designed to reduce references usage. 
This feature is added to be used in special cases 
like teaching data structures and implementing specific design patterns.

.. index:: 
	pair: Using References; ref()

ref()/reference() function
==========================

Syntax:

.. code-block:: ring

	ref(aList|oObject) 	 ---> aList|oObject (Enable Reference Flag) # Short name
	reference(aList|oObject) ---> aList|oObject (Enable Reference Flag) # Long name

Example:

.. code-block:: ring

	aList     = [1,2,3]
	aListCopy = aList	# Copy by Value 
	aList2    = ref(aList)	# Copy by Reference  (RC: 2)
	aList3    = aList 	# Copy by Reference  (RC: 3)
	for item in aList
		item *= 10
	next
	? aList3		# 10 20 30
	? aListCopy		# 1 2 3
	aList2    = NULL
	aList3    = NULL
	aList2    = aList	# Copy by Value
	for item in aList2
		item /= 10
	next
	? aList			# 10 20 30
	? aList2		# 1  2  3 
	

Output:

.. code-block:: none

	10
	20
	30

	1
	2
	3

	10
	20
	30

	1
	2
	3

.. index:: 
	pair: Using References; refcount()

refcount() function
===================

Using the refcount() function we can know how many references exist.

Syntax:

.. code-block:: ring

	refcount(variable) ---> Number (References Count)

Example:

.. code-block:: ring

	aList  = 1:10
	aList2 = ref(aList)
	? refcount(aList)	# 2
	? refcount(aList2)	# 2
	aList3 = aList2
	aList4 = aList
	aList5 = aList4
	? refcount(aList)	# 5
	? refcount(aList2)	# 5
	? refcount(aList3)	# 5
	? refcount(aList4)	# 5
	? refcount(aList5)	# 5
	aList5 = NULL
	aList4 = []
	aList3 = [10]
	? refcount(aList)	# 2
	? refcount(aList2)	# 2

Output:

.. code-block:: none

	2
	2
	5
	5
	5
	5
	5
	2
	2

.. index:: 
	pair: Using References; The Tree Class

The Tree Class
==============

The Tree class is a good example about using the Ref() function.

In this class each object contains a group of objects and these objects have a reference
to the parent object.

Example:

.. code-block:: ring

	Class tree
	
		data parent
		children = []
	
		func set x
			data = x
	
		func value
			return data
	
		func add x
			children + new tree
			nMax = len(children)
			children[nMax].parent = ref(self)
			children[nMax].data = x
			return children[nMax]
	
		func parent
			if ! isObject(parent)
				raise("This node is the root!")
				return
			ok
			return parent
	
		func print
			for x in children
				? x.data
				x.print()
			next

.. tip:: The Tree class already exist in the StdLib 

.. index:: 
	pair: Using References; Circular References

Circular References
===================

Using Ref() we can create circular references

Ring VM can detect them and free memory when the variable is deleted.

Example:

.. code-block:: ring

	aList = [ 10,20,30, ref(aList) ]        
	? aList[4][1]                           
	? aList[4][4][4][4][4][2]               
	? refcount(aList)                       

Output:

.. code-block:: ring

	10
	20
	2

.. index:: 
	pair: Using References; Dependency Injection

Dependency Injection
====================

The next example demonstrates how to apply dependency injection using the Ref() function

Example:

.. code-block:: ring

	func main

		v1 = new myclass1  v2 = new myclass2

		oCont = new Cont(v1,v2)

		v1.value = "one"  v2.value = "two"

		oCont.test()

		v1 = 10 v2 = 20  ? v1 ? v2

		oCont.test()

	class myclass1 value func test ? :myclass1

	class myclass2 value func test ? :myclass2

	class cont o1 o2

		func init myo1,myo2

			o1=ref(myo1) o2=ref(myo2)

		func test

			o1.test()   o2.test()
			? o1.value  ? o2.value

Output:

.. code-block:: ring

	myclass1
	myclass2
	one
	two
	10
	20
	myclass1
	myclass2
	one
	two
